/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package UserInterface;

import Business.ID3.RecordBuilder;
import Business.ID3.Node;
import Business.ID3.Record;
import Business.ID3.DecisionTree;
import Business.Route.Edge;
import Business.Route.Route;
import Business.Route.Vertex;
import Business.Util.RouteUtils;
import Business.Util.TxtFilter;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Line2D;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

/**
 *
 * @author Sonam
 */
public class AnomalyDetectionJPanel extends javax.swing.JPanel {

    /**
     * Creates new form AnomalyDetectionJPanel
     */
    int x[];
    int y[];
    int routeX[];
    int routeY[];
    LinkedHashMap<String, Vertex> vertices;
    HashMap <Vertex,HashMap<Vertex,Double>> previousAlternatives= new HashMap<>();
    private JPanel userProcessContainer;
    private Node decisionTree;
    private Route route;
    private Route finalRoute;
    public AnomalyDetectionJPanel(JPanel userProcessContainer, Node decisionTree) {
        initComponents();
        this.userProcessContainer = userProcessContainer;
        this.decisionTree=decisionTree;
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        plot();
        Graphics2D g2d = (Graphics2D)g;
        if(x!=null && y!=null)
        {
            for (int i = 0; i < 10; i++) {
                g.drawLine(x[i], 0, x[i], 500);
                g.drawLine(0, y[i], 1000, y[i]);
            }
        }
        if(vertices!=null)
        {
            Iterator<Vertex> it = vertices.values().iterator();
            while (it.hasNext())
            {
                Vertex v = it.next();
                Ellipse2D.Double circle = new Ellipse2D.Double(v.getX()-5, v.getY()-5, 10, 10);
                g2d.setColor(v.getColor());
                g2d.fill(circle);
                g2d.setColor(Color.BLUE);
                g2d.drawString("V"+v.getVertexId(),v.getX()+10, v.getY()+15);
            }
        }
        if(route!=null)
        {
            for(Edge e: route.getEdges())
            {
                g2d.setColor(Color.ORANGE);
                g2d.setStroke(new BasicStroke(3));
                g2d.draw(new Line2D.Float(e.getStartV().getX(), e.getStartV().getY(), e.getEndV().getX(),e.getEndV().getY()));
            }
        }
        if(finalRoute!=null)
        {
            for(Edge e: finalRoute.getEdges())
            {
                g2d.setColor(e.getColor());
                g2d.setStroke(new BasicStroke(3));
                g2d.draw(new Line2D.Float(e.getStartV().getX(), e.getStartV().getY(), e.getEndV().getX(),e.getEndV().getY()));
            }
        }
    }
    public void plot() {
        x = new int[10];
        y = new int[10];

        for (int i = 0; i < 10; i++) {
            x[i] = 100 * (i+1);
            y[i] = 50 * (i+1);
        }
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        loadVerticesJButton = new javax.swing.JButton();
        randomizeWeatherJButton = new javax.swing.JButton();
        filePathJTextField = new javax.swing.JTextField();
        browseJButton = new javax.swing.JButton();
        loadRouteJButton = new javax.swing.JButton();

        setMinimumSize(new java.awt.Dimension(1500, 700));
        setPreferredSize(new java.awt.Dimension(1500, 700));

        loadVerticesJButton.setText("Load Vertices");
        loadVerticesJButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                loadVerticesJButtonActionPerformed(evt);
            }
        });

        randomizeWeatherJButton.setText("Randomize Weather");
        randomizeWeatherJButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                randomizeWeatherJButtonActionPerformed(evt);
            }
        });

        browseJButton.setText("Browse");
        browseJButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                browseJButtonActionPerformed(evt);
            }
        });

        loadRouteJButton.setText("Load Route");
        loadRouteJButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                loadRouteJButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(loadVerticesJButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(randomizeWeatherJButton))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(filePathJTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 200, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(29, 29, 29)
                        .addComponent(browseJButton))
                    .addComponent(loadRouteJButton))
                .addContainerGap(1184, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(347, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(loadVerticesJButton)
                    .addComponent(randomizeWeatherJButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(filePathJTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(browseJButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(loadRouteJButton)
                .addGap(264, 264, 264))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void browseJButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_browseJButtonActionPerformed
        // TODO add your handling code here:
        String userDir = System.getProperty("user.home");
        JFileChooser chooser = new JFileChooser(userDir +"/Desktop");
        chooser.setAcceptAllFileFilterUsed(false);
        chooser.addChoosableFileFilter(new TxtFilter());
        chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
        chooser.setMultiSelectionEnabled(false);

        int returnVal = chooser.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = chooser.getSelectedFile();
            String fileName=file.getAbsolutePath();
            filePathJTextField.setText(fileName);
        }
    }//GEN-LAST:event_browseJButtonActionPerformed

    private void loadVerticesJButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_loadVerticesJButtonActionPerformed
        // TODO add your handling code here:
        if(vertices==null)
        {
            vertices= new LinkedHashMap<>();
            int r=0;
            for(int i=0;i<11;i++)
            {
                for(int j=0;j<10;j++)
                {
                    Vertex v= new Vertex();
                    v.setVertexId(r);
                    v.setVertexName("V"+r);
                    v.setX(i*100);
                    v.setY(j*50);
                    v.setWeather(null);
                    vertices.put("V"+r, v);
                    r++;
                }
            }
            
        }
        JOptionPane.showMessageDialog(this,"Vertices Loaded","Information",JOptionPane.INFORMATION_MESSAGE);
        this.validate();
        this.repaint();
    }//GEN-LAST:event_loadVerticesJButtonActionPerformed

    private void randomizeWeatherJButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_randomizeWeatherJButtonActionPerformed
        // TODO add your handling code here:
        if(vertices!=null)
        {
            if(decisionTree==null)
            {
                JOptionPane.showMessageDialog(this,"Decision Tree Not Initialized","Error!!!",JOptionPane.ERROR_MESSAGE);
                return;
            }
            ArrayList<Record> records= RouteUtils.getSampleWeather();
            Iterator<Vertex> it = vertices.values().iterator();
            while (it.hasNext())
            {
                Vertex v = it.next();
                Record r=RouteUtils.getRandomWeather(records);
                v.setWeather(r);
                int decision=DecisionTree.getDecision(r, decisionTree);
                if(decision==1)
                {
                    v.setIsAnomalous(true);
                    v.setColor(Color.RED);
                }
                else
                {
                    v.setIsAnomalous(false);
                    v.setColor(Color.WHITE);
                }
            }
            JOptionPane.showMessageDialog(this,"Weather randomized","Information",JOptionPane.INFORMATION_MESSAGE);
        }
        else
        {
            JOptionPane.showMessageDialog(this,"Please load vertices first!","Information",JOptionPane.INFORMATION_MESSAGE);
        }
        this.route=null;
        this.finalRoute=null;
        this.validate();
        this.repaint();
    }//GEN-LAST:event_randomizeWeatherJButtonActionPerformed

    private void loadRouteJButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_loadRouteJButtonActionPerformed
        // TODO add your handling code here:
        if(vertices==null)
        {
            JOptionPane.showMessageDialog(this,"Please load vertices first","Error!!!", JOptionPane.ERROR_MESSAGE);
            return;
        }
        String filePath= filePathJTextField.getText();
        if(filePath.length()==0)
        {
            JOptionPane.showMessageDialog(this,"Please enter correct file name","Error!!!", JOptionPane.ERROR_MESSAGE);
            return;
        }
        try
        {
            File f = new File(filePath);
            if(!f.exists() || f.isDirectory()) 
            {
                JOptionPane.showMessageDialog(this,"File not exists","Error!!!", JOptionPane.ERROR_MESSAGE);
                return;
            }
        }
        catch(Exception ex)
        {
            JOptionPane.showMessageDialog(this,"File not exists","Error!!!", JOptionPane.ERROR_MESSAGE);
            return;
        }
        System.out.println("**********************************");
        route= RecordBuilder.buildRoute(filePath, vertices);
        checkRouteAnomalies(route);
        this.validate();
        this.repaint();
    }//GEN-LAST:event_loadRouteJButtonActionPerformed

    private Route checkRouteAnomalies(Route route)
    {
        finalRoute= new Route();
        ArrayList<Edge> alternateEdges= new ArrayList<>();
        
        if(route==null)
        {
            JOptionPane.showMessageDialog(this,"Route not exists","Error!!!", JOptionPane.ERROR_MESSAGE);
            return null;
        }
        Vertex lastVertex=null;
        for(int i=0;i<route.getEdges().size()-1;i++)
        {
            if(route.getEdges().get(i).getEndV().isIsAnomalous())
            {
                //Here check if there is any entry in hashmap about previuosly traversed paths.
                //if it is there, take them as alternatives
                //
                boolean found=false;
                HashMap<Vertex,Double> travelledAlternatives=null;
                if(lastVertex!=null)
                {
                    travelledAlternatives=previousAlternatives.get(lastVertex);
                }
                else
                {
                    travelledAlternatives=previousAlternatives.get(route.getEdges().get(i).getStartV());
                }
                
                Vertex leastDistanceVertex=null;
                Double mindistance=5000.0;
                if(travelledAlternatives!=null)
                {
                    Iterator it = travelledAlternatives.entrySet().iterator();
                    while (it.hasNext()) {
                        Map.Entry pair = (Map.Entry)it.next();
                        Vertex vertex=(Vertex) pair.getKey();
                        Double distance=(Double) pair.getValue();
                        if(!vertex.isIsAnomalous())
                        {
                            if(distance<mindistance)
                            {
                                leastDistanceVertex=vertex;
                                mindistance=distance;
                            }
                        }
                    }
                    if(leastDistanceVertex!=null)
                    {
                        found=true;
                        System.out.println("Previously traversed vertex found "+leastDistanceVertex.getVertexName()+" for "+route.getEdges().get(i).getEndV().getVertexName()+" and distance is "+mindistance);
                    }
                }
                
                Edge e=null;
                //Find Alternative point for this edge
                if(found==false)
                {
                    ArrayList<Vertex> alternatives= new ArrayList<>();
                    alternatives= findAlternativePoint(route.getEdges().get(i));
                    if(lastVertex!=null)
                    {
                        e=getBestAlternative(lastVertex, alternatives);
                        HashMap<Vertex,Double> alternates= previousAlternatives.get(e.getEndV());
                        if(alternates==null)
                        {
                            HashMap<Vertex,Double> h= new HashMap<>();
                            h.put(e.getEndV(), e.getDistance());
                            previousAlternatives.put(lastVertex, h);
                        }
                        else
                        {
                            HashMap<Vertex,Double> h=previousAlternatives.get(e.getEndV());
                            h.put(lastVertex, e.getDistance());
                        }
                    }
                    else
                    {
                        e=getBestAlternative(route.getEdges().get(i).getStartV(), alternatives);
                        HashMap<Vertex,Double> alternates= previousAlternatives.get(e.getStartV());
                        if(alternates==null)
                        {
                            HashMap<Vertex,Double> h= new HashMap<>();
                            h.put(e.getEndV(), e.getDistance());
                            previousAlternatives.put(e.getStartV(), h);
                        }
                        else
                        {
                            HashMap<Vertex,Double> h=previousAlternatives.get(e.getStartV());
                            h.put(e.getStartV(), e.getDistance());
                        }
                    }

                    if(!route.getEdges().get(i).getEndV().getAlternatives().contains(e.getEndV()))
                    {
                        route.getEdges().get(i).getEndV().getAlternatives().add(e.getEndV());
                    }
                    if(lastVertex!=null)
                    {
                        e.setStartV(lastVertex);
                    }
                    lastVertex=e.getEndV();
                    e.setColor(Color.RED);
                    alternateEdges.add(e);
                }
                else
                {
                    if(lastVertex!=null)
                    {
                        e= new Edge();
                        e.setStartV(lastVertex);
                        e.setEndV(leastDistanceVertex);
                        e.setDistance(mindistance);
                        e.setColor(Color.GREEN);
                        alternateEdges.add(e);
                        lastVertex=e.getEndV();
                    }
                    else
                    {
                        e= new Edge();
                        e.setStartV(route.getEdges().get(i).getStartV());
                        e.setEndV(leastDistanceVertex);
                        e.setDistance(mindistance);
                        e.setColor(Color.GREEN);
                        alternateEdges.add(e);
                        lastVertex=e.getEndV();
                    }
                }
            }
            else
            {
                Edge e= new Edge();
                if(lastVertex!=null)
                {
                    e.setStartV(lastVertex);
                    if(lastVertex.equals(route.getEdges().get(i).getStartV()))
                    {
                        e.setColor(Color.ORANGE);
                    }
                    else
                    {
                        e.setColor(Color.RED);
                    }
                }
                else
                {
                    e.setStartV(route.getEdges().get(i).getStartV());
                    e.setColor(Color.ORANGE);
                }
                e.setEndV(route.getEdges().get(i).getEndV());
                lastVertex=route.getEdges().get(i).getEndV();
                alternateEdges.add(e);
            }
        }
        Edge e= new Edge();
        e.setStartV(lastVertex);
        e.setEndV(route.getEdges().get(route.getEdges().size()-1).getEndV());
        if(e.getStartV().equals(route.getEdges().get(route.getEdges().size()-1).getStartV())
                && e.getEndV().equals(route.getEdges().get(route.getEdges().size()-1).getEndV()))
        {
            e.setColor(Color.ORANGE);
        }
        else
        {
            e.setColor(Color.RED);
        }
        alternateEdges.add(e);
        finalRoute.getEdges().addAll(alternateEdges);
        return finalRoute;
    }
    
    private Edge getBestAlternative(Vertex start,ArrayList<Vertex> alternatives)
    {
        //Get the best alternative non-anomolous point from the grid alternatives.
        ArrayList<Double> distances= new ArrayList<>();
        Vertex endVertex=null;
        Iterator<Vertex> it= alternatives.iterator();
        while(it.hasNext())
        {
            Vertex v=it.next();
            ArrayList<Edge> intersectingEdges= RecordBuilder.getIntersectingVertex(vertices, start, v);
            boolean okToGo= true;
            if(!intersectingEdges.isEmpty())
            {
                for(Edge e:intersectingEdges)
                {
                    if(e.getEndV().isIsAnomalous())
                    {
                        okToGo=false;
                        break;
                    }
                }
            }
            if(!okToGo)
            {
                it.remove();
            }
        }
        double leastDistance=5000;
        for(Vertex end: alternatives)
        {
            double dist= Math.sqrt(Math.pow((start.getX()-end.getX()), 2)+Math.pow((start.getY()-end.getY()), 2));
            distances.add(dist);
            if(dist<leastDistance)
            {
                endVertex=end;
                leastDistance=dist;
            }
        }
        
        Edge e= new Edge();
        e.setStartV(start);
        e.setEndV(endVertex);
        e.setDistance(leastDistance);
        return e;
    }
    private ArrayList<Vertex> findAlternativePoint(Edge current)
    {
        //Find alternative point on the given grid.
        Vertex toBeReplaced=current.getEndV();
        ArrayList<Vertex> alternatives= new ArrayList<>();
        int x= toBeReplaced.getX();
        int y= 0;
        while(y!=500)
        {
            int vertexNum=(x / 10) + (y / 50);
            Vertex v= vertices.get("V"+vertexNum);
            if(v!=null && !v.isIsAnomalous())
            {
                alternatives.add(v);
            }
            y=y+50;
        }
        return alternatives;
    }    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton browseJButton;
    private javax.swing.JTextField filePathJTextField;
    private javax.swing.JButton loadRouteJButton;
    private javax.swing.JButton loadVerticesJButton;
    private javax.swing.JButton randomizeWeatherJButton;
    // End of variables declaration//GEN-END:variables
}
